#+title: Specification of the Emil Programming Language
#+author: Matt Rudary

* Introduction

Emil is a programming language in the ML family. Its basic syntax and
semantics are similar to Standard ML, with a few extensions thrown in.
Like Standard ML, it is a functional language with strong, static
types and type inference, it is eagerly evaluated by default, and
supports imperative programming, side effects, and exception handling.
It has parametric modules, like Standard ML, but it also supports
overloading through an implicit module feature that is similar in
effect to Haskell's type classes.

This specification is far less formal than e.g. [[https://mitpress.mit.edu/9780262631815/][The Definition of
Standard ML]], but does use a fairly straight-forward BNF to describe
the grammar of the language. The following conventions are used:

- ~[pattern]~ :: optional
- ~pattern*~ :: zero or more repetitions
- ~pattern+~ :: one or more repetitions
- ~pat1 | pat2~ :: alternatives
- ~'X'~ :: terminal

Productions have the form

#+begin_src bnf
  nonterm -> pat1 | pat2 | ... | patn
#+end_src

* Lexical Structure

** Literals

*** Numeric Literals

#+begin_src bnf
  iliteral -> ['-'] iliteral-number ['i' | 'I']
  iliteral-number -> digit-seq
                  |  ('0x' | '0X') hex-digit+ ('_' hex-digit+)*
                  |  ('0o' | '0O') octal-digit+ ('_' octal-digit+)*
                  |  ('0b' | '0B') binary-digit+ ('_' binary-digit+)*
  digit-seq -> decimal-digit+ ('_' decimal-digit+)*

  fpliteral -> ['-'] digit-seq '.' [digit-seq] [fpliteral-exponent]
            |  ['-'] digit-seq fpliteral-exponent
            |  ['-'] digit-seq ('f' | 'F')
            |  ['-'] 'Inf'
            | 'NaN'
  fpliteral-exponent -> ('e' | 'E') ['-' | '+'] decimal-digit+
#+end_src

There are two productions for numeric literals: integral and floating
point.

Integral literals can be specified in decimal, hexadecimal, octal, or
binary notation. The type of the resulting constant is affected by the
suffix attached to the literal. Without a suffix, the literal is a
~bigint~, with ~i~ or ~I~ as a suffix, the literal is an ~int~, and
with ~b~ or ~B~ as a suffix, the literal is a ~byte~. An integral
literal whose value cannot be represented by its type is illegal.

Floating point numbers must have at least one digit before the decimal
point. Finite floating point literals that are greater than the
maximum finite value or less than the minimum finite value
representable by ~float~ are illegal, as are non-zero literals that
are between the maximum negative value and minimum positive value
representable by ~float~.

All numeric literals may contain underscores to separate groups of
digits. Each underscore must be preceded and followed by at least one
digit.

*** String and Character Literals

#+begin_src bnf
  f-string -> ('f' | 'F') string
  string -> '"' (s-char | escape | gap)* '"'
         |  '"""' (m-char | escape)* '"""'
         |  'R"' [rd-char-seq] '(' r-char-seq ')' [rd-char-seq] '"'
  char -> '#"' (s-char | escape) '"'
  gap -> '\' whitespace+ '\'
#+end_src

Characters in Emil are Unicode codepoints. Conceptually, strings are
sequences of characters, though they may be represented differently.

Escape sequences:

| Escape Sequence | Description                       |
|-----------------+-----------------------------------|
| ~\"~            | double quote                      |
| ~\\~            | backslash                         |
| ~\$~            | dollar sign                       |
| ~\a~            | audible bell                      |
| ~\b~            | backspace                         |
| ~\f~            | form feed                         |
| ~\n~            | line feed                         |
| ~\r~            | carriage return                   |
| ~\t~            | horizontal tab                    |
| ~\v~            | vertical tab                      |
| ~\^~ c          | control character (see below)     |
| ~\u~ nnnn       | arbitrary unicode codepoint (hex) |
| ~\U~ nnnnnn     | arbitrary unicode codepoint (hex) |


The "control character" escape uses a character with codepoint between
U+0040 and U+005F (i.e. capital letters, ~@~, ~[~, ~\~, ~]~, ~^~, and
~_~) and produces a character with codepoint 64 less. For example,
~\^@~ produces the null character, ~\^H~ produces backspace, etc.

"Unicode codepoint" escapes must correspond to non-surrogate
codepoints. That is, they must be in the range ~0~-~10FFFF~, excluding
~D800~-~DFFF~.

There are three productions for string literals. The first is similar
to Standard ML's or Haskell's string. An ~s-char~ is any character
except ~"~, ~\~, or the newline character. These literals may contain
"gaps" (pairs of backslashes enclosing only whitespace) which are
ignored. This allows long strings to be written on more than one line.

The second production is similar to Python's multiline strings. An
~m-char~ is any character except ~\~.

The third production is similar to C++'s raw string literals and does
not permit any escaping. It starts with ~R"~, an optional
~rd-char-seq~, and ~(~, and ends with ~)~, the same optional
~rd-char-seq~, and ~"~. An ~rd-char-seq~ is a sequence of characters
excluding ~(~, ~)~, ~\~, the null character, and whitespace. An
~r-char-seq~ is a sequence of any characters at all, except that it
may not contain the string's closing sequence as a substring (that is,
~)~ followed by the initial ~rd-char-seq~ and ~"~).

A character literal is a single ~s-char~ or escape enclosed between
~#"~ and ~"~.

Any of the three types of string literals can be used to create a
formatted string literal by prepending an ~f~ or ~F~. Formatted string
literals may contain two kinds of substring that cause a value to be
interpolated into the string. The first is a ~$~ followed by an
identifier, which is replaced by the value associated with the
identifier, which must be printable. The second is an expression
enclosed by ~${~ and ~}~, which is replaced by the value of the
expression, which must be printable. The contents of the substring
representing the expression need not follow the character restrictions
of the enclosing literal. For example, ~f"Hello, ${"world"}"~ is a
legal formatted string literal, despite the interpolated expression
containing ~"~ characters.

**** TODO define printable

** Identifiers

#+begin_src bnf
  word-id -> word-start word-continue*
  operator-id -> symbol-grapheme-cluster+
  symbol -> ascii-symbol | unicode-symbol
  ascii-symbol -> '!' | '#' | '$' | '%' | '&' | '*' | '+' | '-'
               |  '/' | ':' | '<' | '=' | '>' | '?' | '@' | '\'
               |  '^' | '|' | '~'
#+end_src

Emil permits two types of identifier, word-like identifiers and
operator-like identifiers. Reserved words ([[#reserved-identifiers][listed below]]) may not be
used as identifiers.

An operator identifier consists of one or more symbols, which are
grapheme clusters that start with a character taken from a restricted
subset of ascii symbols or a non-ascii unicode codepoint in the
general categories of Symbol or Punctuation.

Emil's use of word identifiers conforms to Unicode Standard Annex #31,
[[https://www.unicode.org/reports/tr31/tr31-35.html]["Unicode Identifer and Pattern Syntax"]], Revision 35, observing R1
(with a profile) and R4 (with normalization form C). Word identifiers
start with a character from one of the [[https://www.unicode.org/reports/tr31/tr31-35.html#Table_Recommended_Scripts][recommended scripts]] with the
unicode property ~XID_Start~, or ~_~ or ~'~. In the ascii range, the
~XID_Start~ property corresponds to the letters, and this more or less
holds in the other unicode blocks. Characters after the first may
be any starting character, or a character from one of the recommended
scripts with the unicode property ~XID_Continue~. In the ascii range,
this adds the numbers; in other blocks it also adds modifier letters,
combining diacritical marks, etc.

Word identifiers are case sensitive but decomposition-insensitive:
Identifiers with the same value after applying [[https://www.unicode.org/reports/tr15/][Normalization Form C]]
are treated as equivalent. For example, the identifer ~Ã ~ would be the
same whether the source file encoded it as ~U+00E0~ or
~U+0061~~U+0300~.

*** Reserved Identifiers
#+PROPERTY: CUSTOM_ID: reserved-identifiers

The following are reserved words used in the core language and may
not be used as identifiers.

#+begin_example
  Inf    NaN    and    as    case    datatype    else    end
  exception    fn    fun    handle    if    implicit    in    infix
  infixr    let    local    nonfix    of    op    open    prefix
  raise    rec    then    type    val    while    with
  :    _    |    =>    ->    #
#+end_example

**** TODO add more reserved words

** Comments

Comments begin with ~(*~ that is not in a string literal and end with
~)*~. They may be nested, so the number of ~)*~ must match the number
of ~(*~ in a well-formed program. Comments are treated as whitespace
for the purpose of lexical analysis.

** Other syntactic elements

The following tokens are used for various syntactic purposes:

#+begin_src
  (    )    [    ]    ,    ;    .
#+end_src

* Syntax and Semantics

** Core Language

*** Types

**** Built-in Numeric Types

- bigint
- int
- byte
- float

**** Other Built-in Types

- bool
- string
- list
- tuple


* Module Language

* Programs

* Default Prelude and Standard Modules
